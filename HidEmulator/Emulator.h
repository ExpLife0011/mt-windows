#pragma once
#include "HIDDescriptor.h"
#include "EmulatorState.h"

/// <summary>
/// The core implementation of the HidEmulator
/// </summary>
/// <remarks>
/// The HidEmulator works using two ping-pong queues:  One from the synthesis source, and one from the
/// HID class driver.  Requests from the client are put in the synthesis queue, and as read requests
/// come in from the HID class driver, packets are dequeued from the synthesis queue and read into the
/// requests from the class driver.  A typical idle state is for the ReadQueue to have a few packets
/// (typically two, but the number of read packets is system-configuable) and for the SynthQueue to
/// be empty.  If the ReadQueue is empty and the number of packets in the SynthQueue is increasing,
/// it indicates that the system is being overdriven.  You really need to drive the system quite fast
/// to achive this case, but if it happens, severe performance penalties will be the result.
/// </remarks>
class CEmulator
{
public:
	/// <summary>
	/// Constructs a new emulator with the given device object as the hDevice of that emulator
	/// </summary>
	CEmulator(WDFDEVICE hDevice);
	~CEmulator(void);

private:
	// Reflexive device pointer:
	WDFDEVICE m_hDevice;

	// Reflexive IO target
	WDFIOTARGET IoTarget;

	// Collection of IO operations to be fed into hidclass
	WDFQUEUE SynthQueue;

	// Collection of IRPs awaiting fulfillment from hidclass
	WDFQUEUE ReadQueue;

	// Input mode:
	DevInMode InputMode;

	// Emulator state:
	CEmulatorState m_state;

private:
	/// <summary>
	/// Satisfies a matched read request and synthesis request
	/// </summary>
	/// <param name="bSynthesisInitiator">Set to true if the initiator is a synthesis operation</param>
	void Satisfy(WDFREQUEST ReadRequest, WDFREQUEST SynthRequest, bool bSynthesisInitiator);

	/// <summary>
	/// Either queues the specified request to the specified queue, or attempts to use the request to
	/// synthesize an input
	/// </summary>
	template<bool bIsSynthesis>
	void SatisfyOrEnqueue(WDFREQUEST Request);

	/// <summary>
	/// Gets the descriptor that describes the device, including an indication of the number of
	/// report descriptors.
	/// </summary>
	void GetDeviceDescriptor(WDFREQUEST Request);

	/// <summary>
	/// Gets general attributes describe the device
	/// </summary>
	void GetDeviceAttributes(WDFREQUEST Request);

	/// <summary>
	/// Gets the one and only report descriptor describing the reports generated by the device.
	/// The output of this handler is used by the HID class to create child devices.
	/// </summary>
	void GetReportDescriptor(WDFREQUEST Request);

	/// <summary>
	/// String recovery request handler
	/// </summary>
	void GetString(WDFREQUEST Request);

	/// <summary>
	/// Feature get method
	/// </sumamry>
	void GetFeature(WDFREQUEST Request);

	/// <summary>
	/// Feature set method
	/// </sumamry>
	void SetFeature(WDFREQUEST Request);

public:
	const CEmulatorState& GetState(void) const {return m_state;}

	/// <summary>
	/// Causes a request to be pended to this emulator's own internal queue for later synthesis.
	/// Useful for debugging, but also used by CEmulatorContext to restore state in the event of
	/// unexpected client termination.
	/// </summary>
	NTSTATUS QueueSynthesisToSelf(const HID_SYNTEHSIZE_REPORT& report);

	// Generic handlers:
	NTSTATUS DeviceControlInternal(PDEVICE_OBJECT DeviceObject, PIRP Irp);
	EVT_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL EvtInternalDeviceControl;
};

// Make type information available:
WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(CEmulator, GetDeviceContext)

// Forward declarations:
EVT_WDF_OBJECT_CONTEXT_CLEANUP EvtEmulatorCleanup;
EVT_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL EvtInternalDeviceControl;
